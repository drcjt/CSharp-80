using ILCompiler.Compiler.EvaluationStack;
using System.Diagnostics;

namespace ILCompiler.Compiler.Ssa
{
    internal class SsaRenameDominatorTreeVisitor : DominatorTreeVisitor
    {
        private readonly SsaRenameState _renameStack;
        private readonly LocalVariableTable _locals;
        public SsaRenameDominatorTreeVisitor(DominatorTreeNode root, SsaRenameState renameStack, LocalVariableTable locals) : base(root)
        {
            _renameStack = renameStack;
            _locals = locals;
        }

        public override void PostOrderVisit(BasicBlock block)
        {
            _renameStack.PopBlockStacks(block);
        }

        public override void PreOrderVisit(BasicBlock block)
        {
            BlockRenameVariables(block);
            AddPhiArgsToSuccessors(block);
        }

        private void AddPhiArgsToSuccessors(BasicBlock block)
        {
            foreach (var successor in block.Successors)
            {
                foreach (var statement in successor.Statements)
                {
                    if (statement is StoreLocalVariableEntry store && store.Op1 is PhiNode phi)
                    {
                        var localNumber = store.LocalNumber;
                        var ssaNumber = _renameStack.Top(localNumber);

                        AddPhiArg(successor, statement, phi, localNumber, ssaNumber, block);
                    }
                }
            }
        }

        private void AddPhiArg(BasicBlock block, StackEntry statement, PhiNode phi, int localNumber, int ssaNumber, BasicBlock predecessor)
        {
            // First check if there is already a phi arg for this predecessor, if so it should have the same ssaNumber, is so then nothing to do
            foreach (var phiArg in phi.Arguments)
            {
                if (phiArg.Block == predecessor)
                {
                    if (phiArg.SsaNumber == ssaNumber)
                    {
                        return;
                    }

                    throw new InvalidOperationException($"Cannot add Phi arg for local {localNumber} with ssaNumber {ssaNumber} when Phi arg already exists with ssaNumber {phiArg.SsaNumber}");
                }
            }

            // Need to add a new phi arg
            var localVarDescriptor = _locals[localNumber];
            var localVarType = localVarDescriptor.Type;

            var newPhiArg = new PhiArg(localVarType, localNumber, ssaNumber, predecessor);
            phi.Arguments.Add(newPhiArg);

            var phiNode = statement.Prev;
            Debug.Assert(phiNode != null);

            var existingPhiArg = phiNode.Prev;

            if (existingPhiArg != null)
            {
                existingPhiArg.Next = newPhiArg;
                newPhiArg.Prev = existingPhiArg;
            }
            else
            {
                block.FirstNode = newPhiArg;
            }

            newPhiArg.Next = phiNode;
            phiNode.Prev = newPhiArg;

            var localVarSsaDescriptor = localVarDescriptor.GetPerSsaData(ssaNumber);
            localVarSsaDescriptor.AddPhiUse(block);
        }

        private void BlockRenameVariables(BasicBlock block)
        {
            // Walk nodes in statements
            var tree = block.FirstNode;
            if (tree != null)
            { 
                do
                {
                    if (tree is StoreLocalVariableEntry || tree is CallEntry)
                    {
                        RenameDefinition(tree, block);
                    }
                    else if (tree is LocalVariableEntry localVariable)
                    {
                        RenameLocalUse(localVariable, block);
                    }

                    tree = tree.Next;
                } while (tree != null);
            }   
        }

        /// <summary>
        /// Rename a local definition generated by a store or a call node
        /// </summary>
        /// <param name="defNoe"></param>
        /// <param name="block"></param>
        private void RenameDefinition(StackEntry defNode, BasicBlock block)
        {
            if (defNode is StoreLocalVariableEntry localNode)
            {
                var localNumber = localNode.LocalNumber;
                var localVariableDescriptor = _locals[localNumber];
                if (localVariableDescriptor.InSsa)
                {
                    localNode.SsaNumber = RenamePushDef(block, localNumber);
                }
            }
        }

        private void RenameLocalUse(ILocalVariable tree, BasicBlock block)
        {
            var localNumber = tree.LocalNumber;
            var localVariableDescriptor = _locals[localNumber];

            if (localVariableDescriptor.InSsa)
            {
                int ssaNumber = _renameStack.Top(localNumber);
                var ssaDescriptor = localVariableDescriptor.GetPerSsaData(ssaNumber);
                ssaDescriptor.AddUse(block);
            }
        }

        private int RenamePushDef(BasicBlock block, int localNumber)
        {
            var localVariableDescriptor = _locals[localNumber];
            int ssaNumber = localVariableDescriptor.PerSsaData.AllocSsaNumber(() => new LocalSsaVariableDescriptor(block));

            _renameStack.Push(block, localNumber, ssaNumber);

            return ssaNumber;
        }
    }
}
